---
alwaysApply: false
---
# Backend API & ViewSets - Django REST Framework

**Usage**: Apply with `@backend-api-views.mdc` when working on DRF serializers, ViewSets, or API endpoints.

## Serializer Pattern

### Full Serializer (Detail View)
```python
from rest_framework import serializers
from apps.{app}.models import {Module}

class {Module}Serializer(serializers.ModelSerializer):
    """
    Full serializer with computed fields.
    Used for detail views and create/update operations.
    """
    
    # Read-only computed fields
    is_active = serializers.BooleanField(read_only=True)
    created_by_name = serializers.SerializerMethodField()
    
    # Display fields (for choices)
    status_display = serializers.CharField(
        source='get_status_display',
        read_only=True
    )
    
    class Meta:
        model = {Module}
        fields = [
            'id',
            'name',
            'description',
            'status',
            'status_display',
            'is_active',
            'created_by',
            'created_by_name',
            'created_at',
            'updated_at',
        ]
        read_only_fields = ['id', 'created_at', 'updated_at']
    
    def get_created_by_name(self, obj):
        """Get formatted creator name"""
        if obj.created_by:
            full_name = f"{obj.created_by.first_name} {obj.created_by.last_name}".strip()
            return full_name or obj.created_by.email
        return None
    
    def validate_name(self, value):
        """Validate name field"""
        if len(value) < 3:
            raise serializers.ValidationError(
                'Name must be at least 3 characters.'
            )
        return value
    
    def validate(self, data):
        """Cross-field validation"""
        return data
```

### List Serializer (List View)
```python
class {Module}ListSerializer(serializers.ModelSerializer):
    """
    Lightweight serializer for list views.
    Only includes essential fields for performance.
    """
    
    class Meta:
        model = {Module}
        fields = ['id', 'name', 'status', 'created_at']
```

### Nested Serializers
```python
# Read: Nested serializer
class {Module}DetailSerializer(serializers.ModelSerializer):
    category = CategorySerializer(read_only=True)
    tags = TagSerializer(many=True, read_only=True)
    
    class Meta:
        model = {Module}
        fields = '__all__'

# Write: Use IDs
class {Module}WriteSerializer(serializers.ModelSerializer):
    category_id = serializers.IntegerField()
    tag_ids = serializers.ListField(
        child=serializers.IntegerField(),
        required=False
    )
    
    class Meta:
        model = {Module}
        fields = ['name', 'category_id', 'tag_ids']
```

## ViewSet Pattern

### Standard ViewSet
```python
from rest_framework import viewsets, filters, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django_filters.rest_framework import DjangoFilterBackend
from apps.{app}.models import {Module}
from apps.{app}.serializers import {Module}Serializer, {Module}ListSerializer

class {Module}ViewSet(viewsets.ModelViewSet):
    """
    {Module} CRUD operations.
    
    Provides:
    - list: GET /api/{module}s/
    - retrieve: GET /api/{module}s/{id}/
    - create: POST /api/{module}s/
    - update: PUT /api/{module}s/{id}/
    - partial_update: PATCH /api/{module}s/{id}/
    - destroy: DELETE /api/{module}s/{id}/
    """
    
    queryset = {Module}.objects.all()
    permission_classes = [IsAuthenticated]
    
    # Filtering & Search
    filter_backends = [
        DjangoFilterBackend,
        filters.SearchFilter,
        filters.OrderingFilter
    ]
    filterset_fields = ['status']
    search_fields = ['name', 'description']
    ordering_fields = ['created_at', 'name']
    ordering = ['-created_at']
    
    def get_serializer_class(self):
        """Use lightweight serializer for list"""
        if self.action == 'list':
            return {Module}ListSerializer
        return {Module}Serializer
    
    def get_queryset(self):
        """
        CRITICAL: Filter by business (multi-tenancy).
        Always filter to prevent cross-tenant access.
        """
        return {Module}.objects.filter(
            business=self.request.user.business
        ).select_related(
            'created_by'  # Optimize N+1 queries
        )
    
    def perform_create(self, serializer):
        """
        CRITICAL: Auto-set business on create.
        """
        serializer.save(
            business=self.request.user.business,
            created_by=self.request.user
        )
    
    @action(detail=True, methods=['post'])
    def activate(self, request, pk=None):
        """
        Activate a {module}.
        
        POST /api/{module}s/{id}/activate/
        """
        {module} = self.get_object()
        {module}.activate()
        
        serializer = self.get_serializer({module})
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def stats(self, request):
        """
        Get statistics.
        
        GET /api/{module}s/stats/
        """
        queryset = self.filter_queryset(self.get_queryset())
        
        from django.db.models import Count
        stats = {
            'total': queryset.count(),
            'active': queryset.filter(status='active').count(),
            'inactive': queryset.filter(status='inactive').count(),
        }
        
        return Response(stats)
```

## URL Pattern

### Using Router
```python
# apps/{app}/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import {Module}ViewSet

router = DefaultRouter()
router.register(r'{module}s', {Module}ViewSet, basename='{module}')

urlpatterns = [
    path('', include(router.urls)),
]
```

**Remember**: All API URLs are prefixed with `/api/` in main `core/urls.py`

### Custom URLs (Non-ViewSet)
```python
from django.urls import path
from .views import custom_view

urlpatterns = [
    path('{module}s/', custom_view, name='{module}-list'),
    path('{module}s/<int:pk>/', custom_view, name='{module}-detail'),
]
```

**CRITICAL**: Always end URLs with trailing slash `/`

## Error Handling

### ViewSet Error Handling
```python
from rest_framework.exceptions import ValidationError, NotFound

class {Module}ViewSet(viewsets.ModelViewSet):
    def perform_create(self, serializer):
        # Validate business logic
        if some_condition:
            raise ValidationError({
                'field_name': 'Error message'
            })
        
        serializer.save(
            business=self.request.user.business,
            created_by=self.request.user
        )
    
    def retrieve(self, request, pk=None):
        try:
            instance = self.get_object()
        except {Module}.DoesNotExist:
            raise NotFound('Item not found')
        
        serializer = self.get_serializer(instance)
        return Response(serializer.data)
```

## Security Best Practices

### Permissions
```python
from rest_framework.permissions import BasePermission

class IsBusinessOwner(BasePermission):
    """Only allow access to items owned by user's business"""
    
    def has_object_permission(self, request, view, obj):
        return obj.business == request.user.business
```

### Rate Limiting
```python
# settings.py
REST_FRAMEWORK = {
    'DEFAULT_THROTTLE_RATES': {
        'anon': '100/hour',
        'user': '1000/hour',
        'burst': '60/min',
    }
}

# In ViewSet
from rest_framework.throttling import UserRateThrottle

class {Module}ViewSet(viewsets.ModelViewSet):
    throttle_classes = [UserRateThrottle]
```

## Critical Rules Summary

### Backend API
- ✅ Use `settings.AUTH_USER_MODEL` for user references
- ✅ Filter by `business` in `get_queryset()`
- ✅ Set `business` in `perform_create()`
- ✅ URLs end with trailing slash `/`
- ✅ Use select_related()/prefetch_related() for optimization
- ✅ Use proper HTTP methods (POST, GET, PUT, PATCH, DELETE)
- ✅ Implement proper error handling
- ✅ Add appropriate permissions
- ✅ Use two serializers: Full + List

### ViewSet Best Practices
- ✅ Use `ModelViewSet` for CRUD
- ✅ Separate serializers for list/detail
- ✅ Add filtering, search, ordering
- ✅ Custom actions with `@action` decorator
- ✅ Proper permission classes
- ✅ Query optimization in `get_queryset()`
- ✅ Multi-tenancy filtering always

## Quick Reference

**Serializer**: Full + List versions, validation  
**ViewSet**: Filter by business, optimize queries  
**URLs**: Trailing slashes, use routers  
**Security**: Multi-tenancy, permissions, rate limiting  
**Error Handling**: ValidationError, proper HTTP codes  

---

**Reference**: `docs/architecture/BACKEND-ARCHITECTURE.md`
